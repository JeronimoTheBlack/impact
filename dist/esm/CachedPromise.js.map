{"version":3,"file":"CachedPromise.js","sourceRoot":"","sources":["../../src/CachedPromise.ts"],"names":[],"mappings":"AAmBA,MAAM,CAAC,MAAM,aAAa,GAAG;IAC3B,IAAI,EAAE,CAAI,OAAmB,EAAE,EAAE;QAC/B,OAAO;aACJ,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;YACd,iCAAiC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACpD,CAAC,CAAC;aACD,KAAK,CAAC,CAAC,MAAM,EAAE,EAAE;YAChB,gCAAgC,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;QAEL,OAAO,+BAA+B,CAAC,OAAO,CAAC,CAAC;IAClD,CAAC;IACD,SAAS,EAAE,CAAI,KAAQ,EAAE,EAAE;QACzB,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAEvC,OAAO,iCAAiC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IAC3D,CAAC;IACD,QAAQ,EAAE,CAAC,MAAe,EAAE,EAAE;QAC5B,MAAM,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAEvC,OAAO,gCAAgC,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC3D,CAAC;CACF,CAAC;AAEF,SAAS,iCAAiC,CAAI,OAAmB,EAAE,KAAQ;IACzE,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE;QAC5B,MAAM,EAAE,WAAW;QACnB,KAAK;KACN,CAA+B,CAAC;AACnC,CAAC;AAED,SAAS,gCAAgC,CACvC,OAAyB,EACzB,MAAe;IAEf,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE;QAC5B,MAAM,EAAE,UAAU;QAClB,MAAM;KACP,CAA2B,CAAC;AAC/B,CAAC;AAED,SAAS,+BAA+B,CAAI,OAAmB;IAC7D,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE;QAC5B,MAAM,EAAE,SAAS;KAClB,CAA6B,CAAC;AACjC,CAAC;AAED,SAAS,wBAAwB,CAC/B,OAAgB;IAEhB,OAAO,CACL,OAAO,YAAY,OAAO;QAC1B,QAAQ,IAAI,OAAO;QACnB,OAAO,IAAI,OAAO;QAClB,OAAO,CAAC,MAAM,KAAK,WAAW,CAC/B,CAAC;AACJ,CAAC;AAED,SAAS,uBAAuB,CAC9B,OAAgB;IAEhB,OAAO,CACL,OAAO,YAAY,OAAO;QAC1B,QAAQ,IAAI,OAAO;QACnB,QAAQ,IAAI,OAAO;QACnB,OAAO,CAAC,MAAM,KAAK,UAAU,CAC9B,CAAC;AACJ,CAAC;AAED,mFAAmF;AACnF,MAAM,UAAU,UAAU,CAAI,OAAyB;IACrD,IAAI,wBAAwB,CAAC,OAAO,CAAC,EAAE;QACrC,OAAO,OAAO,CAAC,KAAU,CAAC;KAC3B;IAED,IAAI,uBAAuB,CAAC,OAAO,CAAC,EAAE;QACpC,MAAM,OAAO,CAAC,MAAM,CAAC;KACtB;IAED,OAAO;SACJ,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;QACd,iCAAiC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACpD,CAAC,CAAC;SACD,KAAK,CAAC,CAAC,MAAM,EAAE,EAAE;QAChB,gCAAgC,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IACpD,CAAC,CAAC,CAAC;IAEL,MAAM,+BAA+B,CAAC,OAAO,CAAC,CAAC;AACjD,CAAC","sourcesContent":["type TPendingCachedPromise<T> = Promise<T> & {\n  status: \"pending\";\n};\n\ntype TFulfilledCachedPromise<T> = Promise<T> & {\n  status: \"fulfilled\";\n  value: T;\n};\n\ntype TRejectedCachedPromise = Promise<never> & {\n  status: \"rejected\";\n  reason: unknown;\n};\n\nexport type CachedPromise<T> =\n  | TPendingCachedPromise<T>\n  | TFulfilledCachedPromise<T>\n  | TRejectedCachedPromise;\n\nexport const CachedPromise = {\n  from: <T>(promise: Promise<T>) => {\n    promise\n      .then((value) => {\n        makePromiseFulfilledCachedPromise(promise, value);\n      })\n      .catch((reason) => {\n        makePromiseRejectedCachedPromise(promise, reason);\n      });\n\n    return makePromisePendingCachedPromise(promise);\n  },\n  fulfilled: <T>(value: T) => {\n    const promise = Promise.resolve(value);\n\n    return makePromiseFulfilledCachedPromise(promise, value);\n  },\n  rejected: (reason: unknown) => {\n    const promise = Promise.reject(reason);\n\n    return makePromiseRejectedCachedPromise(promise, reason);\n  },\n};\n\nfunction makePromiseFulfilledCachedPromise<T>(promise: Promise<T>, value: T) {\n  return Object.assign(promise, {\n    status: \"fulfilled\",\n    value,\n  }) as TFulfilledCachedPromise<T>;\n}\n\nfunction makePromiseRejectedCachedPromise(\n  promise: Promise<unknown>,\n  reason: unknown\n) {\n  return Object.assign(promise, {\n    status: \"rejected\",\n    reason,\n  }) as TRejectedCachedPromise;\n}\n\nfunction makePromisePendingCachedPromise<T>(promise: Promise<T>) {\n  return Object.assign(promise, {\n    status: \"pending\",\n  }) as TPendingCachedPromise<T>;\n}\n\nfunction isFulfilledCachedPromise(\n  promise: unknown\n): promise is TFulfilledCachedPromise<unknown> {\n  return (\n    promise instanceof Promise &&\n    \"status\" in promise &&\n    \"value\" in promise &&\n    promise.status === \"fulfilled\"\n  );\n}\n\nfunction isRejectedCachedPromise(\n  promise: unknown\n): promise is TRejectedCachedPromise {\n  return (\n    promise instanceof Promise &&\n    \"status\" in promise &&\n    \"reason\" in promise &&\n    promise.status === \"rejected\"\n  );\n}\n\n// There is an official RFC for this hook: https://github.com/reactjs/rfcs/pull/229\nexport function usePromise<T>(promise: CachedPromise<T>) {\n  if (isFulfilledCachedPromise(promise)) {\n    return promise.value as T;\n  }\n\n  if (isRejectedCachedPromise(promise)) {\n    throw promise.reason;\n  }\n\n  promise\n    .then((value) => {\n      makePromiseFulfilledCachedPromise(promise, value);\n    })\n    .catch((reason) => {\n      makePromiseRejectedCachedPromise(promise, reason);\n    });\n\n  throw makePromisePendingCachedPromise(promise);\n}\n"]}