{"version":3,"file":"Container.js","sourceRoot":"","sources":["../../src/Container.tsx"],"names":[],"mappings":";;;;AAAA,uDAMe;AACf,2DAAqC;AAE5B,4BAAQ;AAEV,MAAM,OAAO,GAAG,GAAG,EAAE,CAC1B,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;AADzC,QAAA,OAAO,WACkC;AAEzC,QAAA,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AAItC,MAAM,SAAS,GAAG,IAAA,qBAAa,EAC7B,IAA+C,CAChD,CAAC;AAEK,MAAM,eAAe,GAGvB,CAAC,KAAK,EAAE,EAAE;IACb,MAAM,iBAAiB,GAAG,IAAA,cAAM,GAAsB,CAAC;IACvD,MAAM,eAAe,GAAG,IAAA,kBAAU,EAAC,SAAS,CAAC,CAAC;IAC9C,MAAM,CAAC,SAAS,CAAC,GAAG,IAAA,gBAAQ,EAAC,GAAG,EAAE;QAChC,MAAM,SAAS,GAAG,CAChB,eAAe,IAAI,QAAQ,CAAC,SAAS,CACtC,CAAC,oBAAoB,EAAE,CAAC;QACzB,IAAI,KAAK,CAAC,MAAM,EAAE;YAChB,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,EAAE;gBACrC,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,CAAC;YAChD,CAAC,CAAC,CAAC;SACJ;QACD,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC,CAAC;IAEH,2FAA2F;IAC3F,sDAAsD;IACtD,IAAA,iBAAS,EAAC,GAAG,EAAE;QACb,YAAY,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACxC,OAAO,GAAG,EAAE;YACV,iBAAiB,CAAC,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;gBAC1C,SAAS,CAAC,OAAO,EAAE,CAAC;YACtB,CAAC,CAAsB,CAAC;QAC1B,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,CACL,8BAAC,SAAS,CAAC,QAAQ,IAAC,KAAK,EAAE,SAAS,IAAG,KAAK,CAAC,QAAQ,CAAsB,CAC5E,CAAC;AACJ,CAAC,CAAC;AAhCW,QAAA,eAAe,mBAgC1B;AAEF,SAAgB,UAAU,CAAI,cAA0C;IACtE,MAAM,SAAS,GAAG,IAAA,kBAAU,EAAC,SAAS,CAAC,CAAC;IAExC,OAAO,SAAS,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;AAC3C,CAAC;AAJD,gCAIC","sourcesContent":["import React, {\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport * as tsyringe from \"tsyringe\";\n\nexport { tsyringe };\n\nexport const service = () =>\n  tsyringe.scoped(tsyringe.Lifecycle.ContainerScoped);\n\nexport const inject = tsyringe.inject;\n\nexport type IDisposable = tsyringe.Disposable;\n\nconst diContext = createContext<tsyringe.DependencyContainer>(\n  null as unknown as tsyringe.DependencyContainer\n);\n\nexport const ServiceProvider: React.FC<{\n  children: any;\n  values?: Array<[tsyringe.InjectionToken<unknown>, unknown]>;\n}> = (props) => {\n  const ummountTimeoutRef = useRef<number | undefined>();\n  const parentContainer = useContext(diContext);\n  const [container] = useState(() => {\n    const container = (\n      parentContainer || tsyringe.container\n    ).createChildContainer();\n    if (props.values) {\n      props.values.forEach(([claz, value]) => {\n        container.register(claz, { useValue: value });\n      });\n    }\n    return container;\n  });\n\n  // To ensure we dispose on actual unmount (not with strict mode double running effects), we\n  // use a timeout to ensure that we are still unmounted\n  useEffect(() => {\n    clearTimeout(ummountTimeoutRef.current);\n    return () => {\n      ummountTimeoutRef.current = setTimeout(() => {\n        container.dispose();\n      }) as unknown as number;\n    };\n  }, []);\n\n  return (\n    <diContext.Provider value={container}>{props.children}</diContext.Provider>\n  );\n};\n\nexport function useService<T>(classReference: tsyringe.InjectionToken<T>): T {\n  const container = useContext(diContext);\n\n  return container.resolve(classReference);\n}\n"]}